/**
 * CoworkAny - Reuse Engine
 *
 * Finds and retrieves previously learned knowledge and skills
 * for reuse in new tasks. Integrates with ConfidenceTracker
 * to prioritize reliable learned capabilities.
 */

import type {
    ReuseDecision,
    SkillMatchResult,
    KnowledgeMatchResult,
    SelfLearningConfig,
} from './types';
import { DEFAULT_CONFIG } from './types';
import type { ConfidenceTracker } from './confidenceTracker';

// ============================================================================
// Types
// ============================================================================

export interface SkillRecord {
    id: string;
    name: string;
    description?: string;
    triggers?: string[];
    tags?: string[];
    allowedTools?: string[];
    enabled: boolean;
    isAutoGenerated?: boolean;
}

export interface KnowledgeRecord {
    id: string;
    path: string;
    title: string;
    category: string;
    keywords: string[];
    confidence: number;
}

export interface ReuseEngineDependencies {
    /**
     * List all available skills
     */
    listSkills: () => SkillRecord[];

    /**
     * Search knowledge by query
     */
    searchKnowledge: (query: string) => Promise<Array<{
        path: string;
        title: string;
        score: number;
        category?: string;
    }>>;

    /**
     * Load skill content
     */
    loadSkillContent?: (skillId: string) => Promise<{
        instructions: string;
        scripts?: Record<string, string>;
    }>;

    /**
     * Confidence tracker instance
     */
    confidenceTracker: ConfidenceTracker;
}

// ============================================================================
// ReuseEngine Class
// ============================================================================

export class ReuseEngine {
    private config: SelfLearningConfig;
    private deps: ReuseEngineDependencies;

    constructor(
        deps: ReuseEngineDependencies,
        config?: Partial<SelfLearningConfig>
    ) {
        this.deps = deps;
        this.config = { ...DEFAULT_CONFIG, ...config };
    }

    // ========================================================================
    // Main Reuse Decision
    // ========================================================================

    /**
     * Find reusable capabilities for a query
     */
    async findReusable(query: string): Promise<ReuseDecision> {
        // Search both skills and knowledge in parallel
        const [skillMatches, knowledgeMatches] = await Promise.all([
            this.findMatchingSkills(query),
            this.findMatchingKnowledge(query),
        ]);

        // Determine recommendation
        const recommendation = this.determineRecommendation(
            skillMatches,
            knowledgeMatches
        );

        // Calculate overall confidence
        const topSkillConfidence = skillMatches.length > 0
            ? skillMatches[0].matchScore * (skillMatches[0].successRate || 1)
            : 0;
        const topKnowledgeConfidence = knowledgeMatches.length > 0
            ? knowledgeMatches[0].matchScore
            : 0;
        const confidence = Math.max(topSkillConfidence, topKnowledgeConfidence);

        return {
            shouldUseExisting: recommendation !== 'learn_new',
            matchedSkills: skillMatches,
            matchedKnowledge: knowledgeMatches,
            recommendation,
            confidence,
        };
    }

    // ========================================================================
    // Skill Matching
    // ========================================================================

    /**
     * Find skills that match the query
     */
    private async findMatchingSkills(query: string): Promise<SkillMatchResult[]> {
        const skills = this.deps.listSkills();
        const results: SkillMatchResult[] = [];
        const lowerQuery = query.toLowerCase();
        const queryWords = this.extractWords(lowerQuery);

        for (const skill of skills) {
            if (!skill.enabled) continue;

            let matchScore = 0;
            const matchedTriggers: string[] = [];

            // Check triggers
            if (skill.triggers) {
                for (const trigger of skill.triggers) {
                    const triggerLower = trigger.toLowerCase();
                    if (lowerQuery.includes(triggerLower)) {
                        matchScore += 0.4;
                        matchedTriggers.push(trigger);
                    } else if (this.fuzzyMatch(queryWords, triggerLower)) {
                        matchScore += 0.2;
                        matchedTriggers.push(trigger);
                    }
                }
            }

            // Check tags
            if (skill.tags) {
                for (const tag of skill.tags) {
                    if (lowerQuery.includes(tag.toLowerCase())) {
                        matchScore += 0.15;
                    }
                }
            }

            // Check name and description
            if (skill.name && lowerQuery.includes(skill.name.toLowerCase())) {
                matchScore += 0.25;
            }
            if (skill.description) {
                const descWords = this.extractWords(skill.description.toLowerCase());
                const overlap = this.wordOverlap(queryWords, descWords);
                matchScore += overlap * 0.2;
            }

            // Get confidence from tracker
            const confidenceRecord = this.deps.confidenceTracker.getRecord(skill.id);
            const successRate = confidenceRecord?.successRate ?? 1.0;
            const usageCount = confidenceRecord?.usageHistory.length ?? 0;

            // Boost auto-generated skills if they have good track record
            if (skill.isAutoGenerated && successRate >= 0.8) {
                matchScore += 0.1;
            }

            // Minimum threshold to include
            if (matchScore >= 0.2) {
                results.push({
                    skillId: skill.id,
                    skillName: skill.name,
                    matchScore: Math.min(matchScore, 1.0),
                    matchedTriggers,
                    usageCount,
                    successRate,
                });
            }
        }

        // Sort by weighted score (match * success rate)
        return results
            .sort((a, b) => {
                const aScore = a.matchScore * a.successRate;
                const bScore = b.matchScore * b.successRate;
                return bScore - aScore;
            })
            .slice(0, 5);
    }

    // ========================================================================
    // Knowledge Matching
    // ========================================================================

    /**
     * Find knowledge that matches the query
     */
    private async findMatchingKnowledge(query: string): Promise<KnowledgeMatchResult[]> {
        try {
            const searchResults = await this.deps.searchKnowledge(query);
            const results: KnowledgeMatchResult[] = [];

            for (const result of searchResults) {
                // Get confidence from tracker
                const confidenceRecord = this.deps.confidenceTracker.getRecord(result.path);
                const confidence = confidenceRecord?.currentConfidence ?? result.score;

                // Skip low confidence knowledge
                if (confidence < this.config.minConfidenceToAutoUse * 0.5) {
                    continue;
                }

                results.push({
                    knowledgeId: result.path,
                    title: result.title,
                    matchScore: result.score * confidence,
                    path: result.path,
                    category: result.category || 'general',
                });
            }

            return results
                .sort((a, b) => b.matchScore - a.matchScore)
                .slice(0, 5);
        } catch (error) {
            console.warn('[ReuseEngine] Knowledge search failed:', error);
            return [];
        }
    }

    // ========================================================================
    // Recommendation Logic
    // ========================================================================

    /**
     * Determine the best recommendation
     */
    private determineRecommendation(
        skills: SkillMatchResult[],
        knowledge: KnowledgeMatchResult[]
    ): 'use_skill' | 'use_knowledge' | 'learn_new' | 'hybrid' {
        const bestSkill = skills[0];
        const bestKnowledge = knowledge[0];

        // No matches at all
        if (!bestSkill && !bestKnowledge) {
            return 'learn_new';
        }

        // Strong skill match with good success rate
        if (bestSkill &&
            bestSkill.matchScore >= 0.6 &&
            bestSkill.successRate >= this.config.minConfidenceToAutoUse) {
            return 'use_skill';
        }

        // Strong knowledge match
        if (bestKnowledge && bestKnowledge.matchScore >= 0.7) {
            // If skill also exists but lower match, consider hybrid
            if (bestSkill && bestSkill.matchScore >= 0.4) {
                return 'hybrid';
            }
            return 'use_knowledge';
        }

        // Moderate skill match
        if (bestSkill && bestSkill.matchScore >= 0.4) {
            return 'use_skill';
        }

        // Moderate knowledge match
        if (bestKnowledge && bestKnowledge.matchScore >= 0.4) {
            return 'use_knowledge';
        }

        // Low matches - consider learning new
        return 'learn_new';
    }

    // ========================================================================
    // Skill Loading
    // ========================================================================

    /**
     * Load skill content for use in task
     */
    async loadSkillForTask(
        skillId: string,
        taskContext: string
    ): Promise<{
        instructions: string;
        scripts?: Record<string, string>;
        contextHint: string;
    } | null> {
        if (!this.deps.loadSkillContent) {
            return null;
        }

        try {
            const content = await this.deps.loadSkillContent(skillId);

            // Generate context hint based on task
            const contextHint = this.generateContextHint(content.instructions, taskContext);

            return {
                ...content,
                contextHint,
            };
        } catch (error) {
            console.warn(`[ReuseEngine] Failed to load skill ${skillId}:`, error);
            return null;
        }
    }

    /**
     * Generate a context hint for the skill
     */
    private generateContextHint(instructions: string, taskContext: string): string {
        // Extract relevant sections from instructions
        const lines = instructions.split('\n');
        const relevantLines: string[] = [];
        const taskWords = this.extractWords(taskContext.toLowerCase());

        for (const line of lines) {
            const lineWords = this.extractWords(line.toLowerCase());
            if (this.wordOverlap(taskWords, lineWords) > 0.3) {
                relevantLines.push(line);
            }
        }

        if (relevantLines.length > 0) {
            return `Relevant sections for this task:\n${relevantLines.slice(0, 5).join('\n')}`;
        }

        return 'Use the skill instructions to complete this task.';
    }

    // ========================================================================
    // Usage Recording
    // ========================================================================

    /**
     * Record usage of a skill or knowledge
     */
    async recordUsage(
        entityId: string,
        taskId: string,
        success: boolean,
        details?: string
    ): Promise<void> {
        this.deps.confidenceTracker.recordUsage(entityId, success, taskId, details);
    }

    /**
     * Record batch usage results
     */
    async recordBatchUsage(
        results: Array<{
            entityId: string;
            taskId: string;
            success: boolean;
            details?: string;
        }>
    ): Promise<void> {
        for (const result of results) {
            this.deps.confidenceTracker.recordUsage(
                result.entityId,
                result.success,
                result.taskId,
                result.details
            );
        }
    }

    // ========================================================================
    // Utility Methods
    // ========================================================================

    /**
     * Extract words from text
     */
    private extractWords(text: string): string[] {
        return text
            .toLowerCase()
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(w => w.length > 2);
    }

    /**
     * Calculate word overlap ratio
     */
    private wordOverlap(words1: string[], words2: string[]): number {
        if (words1.length === 0 || words2.length === 0) return 0;

        const set1 = new Set(words1);
        const set2 = new Set(words2);
        let overlap = 0;

        for (const word of set1) {
            if (set2.has(word)) overlap++;
        }

        return overlap / Math.min(set1.size, set2.size);
    }

    /**
     * Fuzzy match query words against text
     */
    private fuzzyMatch(queryWords: string[], text: string): boolean {
        const textWords = this.extractWords(text);
        const matchCount = queryWords.filter(qw =>
            textWords.some(tw => tw.includes(qw) || qw.includes(tw))
        ).length;

        return matchCount >= Math.ceil(queryWords.length * 0.5);
    }

    // ========================================================================
    // Statistics
    // ========================================================================

    /**
     * Get reuse statistics
     */
    getStatistics(): {
        totalSkills: number;
        totalAutoGenerated: number;
        avgSuccessRate: number;
        topSkills: Array<{ id: string; name: string; usageCount: number; successRate: number }>;
    } {
        const skills = this.deps.listSkills();
        const autoGenerated = skills.filter(s => s.isAutoGenerated);

        let totalSuccessRate = 0;
        let countWithStats = 0;
        const skillStats: Array<{ id: string; name: string; usageCount: number; successRate: number }> = [];

        for (const skill of skills) {
            const record = this.deps.confidenceTracker.getRecord(skill.id);
            if (record) {
                totalSuccessRate += record.successRate;
                countWithStats++;
                skillStats.push({
                    id: skill.id,
                    name: skill.name,
                    usageCount: record.usageHistory.length,
                    successRate: record.successRate,
                });
            }
        }

        return {
            totalSkills: skills.length,
            totalAutoGenerated: autoGenerated.length,
            avgSuccessRate: countWithStats > 0 ? totalSuccessRate / countWithStats : 0,
            topSkills: skillStats
                .sort((a, b) => b.usageCount - a.usageCount)
                .slice(0, 5),
        };
    }

    /**
     * Get skills that might need attention (low success rate)
     */
    getSkillsNeedingAttention(): SkillRecord[] {
        const skills = this.deps.listSkills();
        const needsAttention: SkillRecord[] = [];

        for (const skill of skills) {
            const record = this.deps.confidenceTracker.getRecord(skill.id);
            if (record && record.usageHistory.length >= 3 && record.successRate < 0.5) {
                needsAttention.push(skill);
            }
        }

        return needsAttention;
    }
}

// ============================================================================
// Factory Function
// ============================================================================

export function createReuseEngine(
    deps: ReuseEngineDependencies,
    config?: Partial<SelfLearningConfig>
): ReuseEngine {
    return new ReuseEngine(deps, config);
}
