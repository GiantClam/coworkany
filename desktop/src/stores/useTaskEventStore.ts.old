/**
 * Task Event Store
 *
 * Zustand store wrapping the TaskEventStore for React integration.
 * Receives events from Tauri and updates UI state reactively.
 */

import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { invoke } from '@tauri-apps/api/core';
import type {
    TaskStatus,
    TaskEvent,
    PlanStep,
    ToolCall,
    Effect,
    Patch,
    ChatMessage,
    AuditEvent,
    IpcResponse,
    TaskSession,
} from '../types';

// Re-export types for backward compatibility
export type {
    TaskStatus,
    TaskEvent,
    PlanStep,
    ToolCall,
    Effect,
    Patch,
    ChatMessage,
    AuditEvent,
    IpcResponse,
    TaskSession,
};

type SessionsSnapshot = {
    sessions: TaskSession[];
    activeTaskId: string | null;
};

let persistTimer: ReturnType<typeof setTimeout> | null = null;

async function persistSessions(snapshot: SessionsSnapshot): Promise<void> {
    try {
        await invoke('save_sessions', { input: snapshot });
    } catch (error) {
        console.warn('[TaskEventStore] Failed to save sessions:', error);
    }
}

function schedulePersist(snapshot: SessionsSnapshot): void {
    if (persistTimer) {
        clearTimeout(persistTimer);
    }
    persistTimer = setTimeout(() => {
        persistTimer = null;
        void persistSessions(snapshot);
    }, 500);
}

// ============================================================================
// Store State
// ============================================================================

interface TaskEventStoreState {
    sessions: Map<string, TaskSession>;
    activeTaskId: string | null;
    sidecarConnected: boolean;
    pendingResponses: Map<string, IpcResponse>;
    auditEvents: AuditEvent[];

    // Actions
    addEvent: (event: TaskEvent) => void;
    addAuditEvent: (event: AuditEvent) => void;
    getSession: (taskId: string) => TaskSession | undefined;
    setActiveTask: (taskId: string | null) => void;
    setSidecarConnected: (connected: boolean) => void;
    handleIpcResponse: (response: IpcResponse) => void;
    reset: () => void;
    hydrate: (snapshot: SessionsSnapshot) => void;
}

// ============================================================================
// Create Empty Session
// ============================================================================

function createEmptySession(taskId: string): TaskSession {
    const now = new Date().toISOString();
    return {
        taskId,
        status: 'idle',
        planSteps: [],
        toolCalls: [],
        effects: [],
        patches: [],
        messages: [],
        events: [],
        createdAt: now,
        updatedAt: now,
    };
}

function appendSystemMessage(session: TaskSession, event: TaskEvent, content: string): TaskSession {
    return {
        ...session,
        messages: [
            ...session.messages,
            {
                id: event.id,
                role: 'system',
                content,
                timestamp: event.timestamp,
            },
        ],
    };
}

// ============================================================================
// Event Reducer
// ============================================================================

function applyEvent(session: TaskSession, event: TaskEvent): TaskSession {
    // Prevent duplicate events
    if (session.events.some(e => e.id === event.id)) {
        return session;
    }

    const updated: TaskSession = {
        ...session,
        events: [...session.events, event],
        updatedAt: new Date().toISOString(),
    };

    const payload = event.payload as Record<string, unknown>;

    switch (event.type) {
        case 'TASK_STARTED':
            return {
                ...updated,
                status: 'running',
                title: payload.title as string,
                workspacePath: (payload.context as Record<string, unknown>)?.workspacePath as string, // Capture workspace association
                messages: [
                    ...updated.messages,
                    {
                        id: event.id,
                        role: 'user',
                        content:
                            ((payload.context as Record<string, unknown>)?.userQuery as string) ??
                            (payload.description as string) ??
                            '',
                        timestamp: event.timestamp,
                    },
                ],
            };

        case 'PLAN_UPDATED':
            return {
                ...updated,
                planSummary: payload.summary as string,
                planSteps: (payload.steps as PlanStep[]) || [],
            };

        case 'TASK_FINISHED':
            return {
                ...updated,
                status: 'finished',
                summary: payload.summary as string,
                assistantDraft: undefined,
            };

        case 'TASK_FAILED':
            return {
                ...updated,
                status: 'failed',
                summary: payload.error as string,
                assistantDraft: undefined,
            };

        case 'TASK_STATUS': {
            const status = payload.status as TaskStatus;
            return {
                ...updated,
                status: status ?? updated.status,
                assistantDraft: status === 'running' ? updated.assistantDraft : undefined,
            };
        }

        case 'TASK_HISTORY_CLEARED': {
            return {
                ...updated,
                messages: [
                    {
                        id: event.id,
                        role: 'system',
                        content: 'Conversation history cleared.',
                        timestamp: event.timestamp,
                    },
                ],
                assistantDraft: undefined,
            };
        }

        case 'CHAT_MESSAGE': {
            const role = (payload.role as 'user' | 'assistant' | 'system') ?? 'system';
            const content = (payload.content as string) ?? '';
            return {
                ...updated,
                messages: [
                    ...updated.messages,
                    {
                        id: event.id,
                        role,
                        content,
                        timestamp: event.timestamp,
                    },
                ],
            };
        }

        case 'TOOL_CALLED':
            return appendSystemMessage(
                {
                    ...updated,
                    toolCalls: [
                        ...updated.toolCalls,
                        {
                            toolName: payload.toolName as string,
                            toolId: payload.toolId as string,
                            source: payload.source as string,
                        },
                    ],
                },
                event,
                `Tool called: ${(payload.toolName as string) || 'unknown'}`
            );

        case 'EFFECT_REQUESTED':
            const request = payload.request as Record<string, unknown>;
            return appendSystemMessage(
                {
                    ...updated,
                    effects: [
                        ...updated.effects,
                        {
                            requestId: request.id as string,
                            effectType: request.effectType as string,
                            riskLevel: payload.riskLevel as number,
                        },
                    ],
                },
                event,
                `Effect requested: ${(request.effectType as string) || 'unknown'} (risk ${(payload.riskLevel as number) || 0}/10)`
            );

        case 'EFFECT_APPROVED':
        case 'EFFECT_DENIED': {
            const response = payload.response as Record<string, unknown>;
            const approved = event.type === 'EFFECT_APPROVED';
            return appendSystemMessage(
                {
                    ...updated,
                    effects: updated.effects.map((effect) =>
                        effect.requestId === response.requestId
                            ? { ...effect, approved }
                            : effect
                    ),
                },
                event,
                `Effect ${approved ? 'approved' : 'denied'}`
            );
        }

        case 'PATCH_PROPOSED': {
            const patch = payload.patch as Record<string, unknown>;
            return appendSystemMessage(
                {
                    ...updated,
                    patches: [
                        ...updated.patches,
                        {
                            patchId: patch.id as string,
                            filePath: patch.filePath as string | undefined,
                            status: 'proposed',
                        },
                    ],
                },
                event,
                `Patch proposed: ${(patch.filePath as string) || 'unknown'}`
            );
        }

        case 'PATCH_APPLIED':
            return appendSystemMessage(
                {
                    ...updated,
                    patches: updated.patches.map((patch) =>
                        patch.patchId === payload.patchId
                            ? { ...patch, status: 'applied', filePath: payload.filePath as string }
                            : patch
                    ),
                },
                event,
                `Patch applied: ${(payload.filePath as string) || 'unknown'}`
            );

        case 'PATCH_REJECTED':
            return appendSystemMessage(
                {
                    ...updated,
                    patches: updated.patches.map((patch) =>
                        patch.patchId === payload.patchId
                            ? { ...patch, status: 'rejected' }
                            : patch
                    ),
                },
                event,
                `Patch rejected`
            );

        case 'TOOL_RESULT': {
            const summary =
                (payload.resultSummary as string | undefined) ??
                (payload.success ? 'Tool finished successfully' : 'Tool failed');
            return appendSystemMessage(updated, event, `Tool result: ${summary}`);
        }

        case 'AGENT_IDENTITY_ESTABLISHED': {
            const identity = payload.identity as Record<string, unknown> | undefined;
            const sessionId = identity?.sessionId as string | undefined;
            return appendSystemMessage(
                updated,
                event,
                `Agent identity established${sessionId ? ` (${sessionId})` : ''}`
            );
        }

        case 'MCP_GATEWAY_DECISION': {
            const toolName = payload.toolName as string | undefined;
            const action = payload.decision as string | undefined;
            return appendSystemMessage(
                updated,
                event,
                `MCP decision${toolName ? ` for ${toolName}` : ''}: ${action ?? 'unknown'}`
            );
        }

        case 'RUNTIME_SECURITY_ALERT': {
            const threat = payload.threatType as string | undefined;
            return appendSystemMessage(
                updated,
                event,
                `Security alert${threat ? `: ${threat}` : ''}`
            );
        }

        case 'TEXT_DELTA': {
            const role = payload.role as string | undefined;
            if (role === 'thinking') {
                return updated;
            }
            const delta = (payload.delta as string) ?? '';
            const draft = (updated.assistantDraft ?? '') + delta;
            let messages = updated.messages;

            if (messages.length === 0 || messages[messages.length - 1].role !== 'assistant') {
                messages = [
                    ...messages,
                    {
                        id: event.id,
                        role: 'assistant',
                        content: draft,
                        timestamp: event.timestamp,
                    },
                ];
            } else {
                const last = messages[messages.length - 1];
                messages = [
                    ...messages.slice(0, -1),
                    {
                        ...last,
                        content: draft,
                    },
                ];
            }

            return {
                ...updated,
                assistantDraft: draft,
                messages,
            };
        }

        default:
            return updated;
    }
}

// ============================================================================
// Store
// ============================================================================

export const useTaskEventStore = create<TaskEventStoreState>()(
    subscribeWithSelector((set, get) => ({
        sessions: new Map(),
        activeTaskId: null,
        sidecarConnected: false,
        pendingResponses: new Map(),
        auditEvents: [],

        addEvent: (event: TaskEvent) => {
            console.log('[TaskEventStore] addEvent called:', event.type, event.taskId);
            set((state) => {
                const sessions = new Map(state.sessions);
                const existing = sessions.get(event.taskId) ?? createEmptySession(event.taskId);
                const updated = applyEvent(existing, event);
                sessions.set(event.taskId, updated);
                console.log('[TaskEventStore] Session updated, messages count:', updated.messages.length);
                const snapshot: SessionsSnapshot = {
                    sessions: Array.from(sessions.values()),
                    activeTaskId: state.activeTaskId,
                };
                schedulePersist(snapshot);
                return { sessions };
            });
        },

        addAuditEvent: (event: AuditEvent) => {
            set((state) => ({
                auditEvents: [...state.auditEvents, event],
            }));
        },

        getSession: (taskId: string) => {
            return get().sessions.get(taskId);
        },

        setActiveTask: (taskId: string | null) => {
            set((state) => {
                const next = { activeTaskId: taskId };
                const snapshot: SessionsSnapshot = {
                    sessions: Array.from(state.sessions.values()),
                    activeTaskId: taskId,
                };
                schedulePersist(snapshot);
                return next;
            });
        },

        setSidecarConnected: (connected: boolean) => {
            set({ sidecarConnected: connected });
        },

        handleIpcResponse: (response: IpcResponse) => {
            set((state) => {
                const pendingResponses = new Map(state.pendingResponses);
                pendingResponses.set(response.commandId, response);

                // Convert response to TaskEvent for active session if applicable
                if (response.type === 'request_effect_response') {
                    const payload = response.payload as Record<string, unknown>;
                    const effectResponse = payload.response as Record<string, unknown>;
                    const approved = effectResponse?.approved as boolean;
                    const taskId = state.activeTaskId ?? 'global';
                    const session = state.sessions.get(taskId);
                    if (session) {
                        const event: TaskEvent = {
                            id: response.commandId,
                            taskId,
                            timestamp: response.timestamp,
                            sequence: session.events.length + 1,
                            type: approved ? 'EFFECT_APPROVED' : 'EFFECT_DENIED',
                            payload: { response: effectResponse },
                        };
                        const sessions = new Map(state.sessions);
                        sessions.set(taskId, applyEvent(session, event));
                        return { sessions, pendingResponses };
                    }
                }

                if (response.type === 'apply_patch_response') {
                    const payload = response.payload as Record<string, unknown>;
                    const success = payload.success as boolean;
                    const taskId = state.activeTaskId ?? 'global';
                    const session = state.sessions.get(taskId);
                    if (session) {
                        const event: TaskEvent = {
                            id: response.commandId,
                            taskId,
                            timestamp: response.timestamp,
                            sequence: session.events.length + 1,
                            type: success ? 'PATCH_APPLIED' : 'PATCH_REJECTED',
                            payload: {
                                patchId: payload.patchId,
                                filePath: payload.filePath,
                                reason: payload.error,
                            },
                        };
                        const sessions = new Map(state.sessions);
                        sessions.set(taskId, applyEvent(session, event));
                        return { sessions, pendingResponses };
                    }
                }

                return { pendingResponses };
            });
        },

        reset: () => {
            set({
                sessions: new Map(),
                activeTaskId: null,
                pendingResponses: new Map(),
                auditEvents: [],
            });
            schedulePersist({ sessions: [], activeTaskId: null });
        },

        hydrate: (snapshot: SessionsSnapshot) => {
            const map = new Map<string, TaskSession>();
            for (const session of snapshot.sessions) {
                // Fix stale 'running' status from previous sessions
                // When app restarts, any 'running' task is actually interrupted/failed
                const cleanedSession = session.status === 'running'
                    ? { ...session, status: 'failed' as TaskStatus, summary: 'Task interrupted by app restart' }
                    : session;
                map.set(cleanedSession.taskId, cleanedSession);
            }
            let activeTaskId = snapshot.activeTaskId ?? null;
            if (!activeTaskId && snapshot.sessions.length > 0) {
                const sorted = [...snapshot.sessions].sort(
                    (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
                );
                activeTaskId = sorted[0]?.taskId ?? null;
            }
            set({
                sessions: map,
                activeTaskId,
            });
        },
    }))
);

// ============================================================================
// Selectors
// ============================================================================

export const useActiveSession = () => {
    return useTaskEventStore((state) => {
        if (!state.activeTaskId) return undefined;
        return state.sessions.get(state.activeTaskId);
    });
};

export const useSidecarConnected = () => {
    return useTaskEventStore((state) => state.sidecarConnected);
};

export async function hydrateSessions(): Promise<void> {
    try {
        const result = await invoke<{ payload?: SessionsSnapshot }>('load_sessions');
        const snapshot = result?.payload;
        if (snapshot) {
            useTaskEventStore.getState().hydrate({
                sessions: snapshot.sessions ?? [],
                activeTaskId: snapshot.activeTaskId ?? null,
            });
        }
    } catch (error) {
        console.warn('[TaskEventStore] Failed to load sessions:', error);
    }
}
